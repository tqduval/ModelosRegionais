runsum <- runsum/ds
# Analisa cada data.frame dentro da lista 'data' (por isso o lapply)
max.subset <-
lapply(1:length(which.mon),
function(m.i){
# Retornar um vetor lógico que marca como TRUE quais os meses que estão dentro do argumento 'which.mon'
subset <- is.element(as.POSIXlt(data.s[, names[1]])$mon, which.mon[[m.i]])
# Agrupa as observações por ano e compara o percentual de falhas com o na.accept
# ctapply() é uma versão otimizada da função tapply() que faz comparações baseadas em uma categoria (nesse caso o ano)
max <- fastmatch::ctapply(X = runsum[subset],                                           # somas móveis de cada mês analisado
INDEX = (as.POSIXlt(data.s[, names[1]])$year + 1900)[subset], # ano de cada mês com subset = TRUE
FUN = function(vec){                                          # máximo anual se n.falhas <= na.accept
# Número de NAs no ano agrupado
n.na <- sum(is.na(vec))
# Retorna o máximo anual caso a função tenha número de falhas aceitável
max <- ifelse(n.na <= na.accept*length(vec),
max(vec, na.rm = TRUE),
NA)
return(max)
})
# Data.frame resultante de máximos
df <- data.frame(xdat = max,                      # intensidades máximas anuais
ds = ds,                         # durações (cte em todo o conjunto)
year = as.numeric((names(max))), # converte os nomes de max (contém strings dos anos) em numérico
mon = deparse(which.mon[[m.i]]), # sequencia de meses analisados
station = station,               # nome da estação que está sendo analisada
stringsAsFactors = FALSE)
# Investigar: guardar a data em que ocorreu o máximo
return(df)
})
df <- do.call(rbind, max.subset)
return(df) # máximos para uma duração
}
# Chamar a função agg.ts dentro do parLapply (processamento paralelo) para calcular os máximos para todas as durações
if(cl > 1){ # Aplicar processamento paralelo
clust <- parallel::makeCluster(cl, type = "PSOCK")
data.agg <- parallel::parLapply(cl = clust,
X = ds,
fun = agg.ts)
parallel::stopCluster(clust)
} else{     # Não aplicar processamento paralelo
data.agg <- lapply(X = ds, agg.ts)
}
# Data.frame com máximos anuais para todas as durações em 'ds'
df <- do.call(rbind, data.agg)
return(df)
}
# Define quais estações utilizar
if(is.null(which.stations))which.stations <-
if(is.null(names(data))){
1:length(data)
} else{
names(data)
}
# Chama a função agg.station com lapply p/ agregar as durações para todas as estações
station.list <- pbapply::pblapply(which.stations, agg.station)
return(do.call('rbind', station.list))
}
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/600                              # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- IDF::IDF.agg(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/600                              # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"))
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/600                              # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"))
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
data_by_ts[[ts]]
current_list[[1]]
current_list[[1]] %>% class
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"))
gc()
View(current_list)
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/600                              # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
current_list[[1]]
teste <- current_list[[1]]
teste[, names[1]][2]
teste[, names[1]][1]
teste[, names[1]][3]
teste[, names[1]][1]
names[1]
teste[, names[1]]
teste[, names[1]]
teste[, names[1]][]
teste[, names[1]][1]
teste[1, names[1]]
fun_agg_timeseries <- function(data,
ds,
na.accept = 0,
which.stations = NULL,
which.mon = list(0:11),
names = c("date", "RR"),
cl = 1){
# Confere se o argumento 'data' é uma lista
if(!inherits(data, "list")){
stop("Argument 'data' must be a list, insted it is a: ", class(data))
}
# Função 2: análises preliminares de consistência e encontrar a resolução temporal da estação 'dtime'
# Essa função calcula qual a resolução temporal que a estação apresenta baseado na diferença entre a data das duas primeiras observações
# depois confere se existe alguma observação nessa estação que a resolução sejea diferente e para o progresso da função caso encontre alguma
# que a diferença seja maior que a tolerância estabelecida e roda ao final a função de agregação
agg.station <- function(station){
# Extrai o data.frame para uma dada estação da lista
data.s <- data[[station]]
# Confere se data.s tem somente duas colunas, se tiver mais manter somente as em names
if (ncol(data.s) != 2) {
data.s <- data.s[, names, drop = FALSE]
}
# Confere se a lista contém data.frames
if(!is.data.frame(data.s)){
stop("Elements of 'data' must be data.frames. But element ", station, " contains: ", class(data.s))
}
# Usa is.element() parar conferir se os nomes do argumento 'names' são os mesmos nomes das colunas dos data.frames
if(sum(is.element(names[1:2], names(data.s))) != 2){
stop("Data.frame of station ", station, " does not contain $", names[1], " or $", names[2], ".")
}
# Calcula a resolução temporal da estação baseado na diferença de tempo entre as duas primeiras observações do data.frame
dtime <- as.numeric(x = (data.s[2, names[1]] - data.s[1, names[1]]),
units = "hours")
# Confere as durações ewm 'ds' são múltiplas da resolução temporal da estação
if(any((ds/dtime) %% 1 > 1e-8)){
stop("At least one of the given aggregation durations is not multiple of the time resolution = ", dtime, " hours at station ", station, ".")
}
# Função 1: agregar por durações e encontrar o máximo anual de cada uma
# Usa o pacote RcppRoll para implementar funções do C++ de janela móvel (roll_sum e roll_mean) mais rápido que alternativas do R
agg.ts <- function(ds){
# Criar um vetor de somas móveis da coluna de precipitação, usando uma janela de ds/dtime
runsum <- RcppRoll::roll_sum(x = data.s[, names[2]], # vetor com dados da coluna 2 (precipitação)
n = round(ds/dtime),    # tamanho da janela móvel (ds é o vetor c/ as durações e dtime a resolução da estação)
fill = NA,              # preenche as pontas com NA
align = "right")        # alinha a janela à direita (no índice i)
# Converte a soma acumulada em intensidade por hora
runsum <- runsum/ds
# Analisa cada data.frame dentro da lista 'data' (por isso o lapply)
max.subset <-
lapply(1:length(which.mon),
function(m.i){
# Retornar um vetor lógico que marca como TRUE quais os meses que estão dentro do argumento 'which.mon'
subset <- is.element(as.POSIXlt(data.s[, names[1]])$mon, which.mon[[m.i]])
# Agrupa as observações por ano e compara o percentual de falhas com o na.accept
# ctapply() é uma versão otimizada da função tapply() que faz comparações baseadas em uma categoria (nesse caso o ano)
max <- fastmatch::ctapply(X = runsum[subset],                                           # somas móveis de cada mês analisado
INDEX = (as.POSIXlt(data.s[, names[1]])$year + 1900)[subset], # ano de cada mês com subset = TRUE
FUN = function(vec){                                          # máximo anual se n.falhas <= na.accept
# Número de NAs no ano agrupado
n.na <- sum(is.na(vec))
# Retorna o máximo anual caso a função tenha número de falhas aceitável
max <- ifelse(n.na <= na.accept*length(vec),
max(vec, na.rm = TRUE),
NA)
return(max)
})
# Data.frame resultante de máximos
df <- data.frame(xdat = max,                      # intensidades máximas anuais
ds = ds,                         # durações (cte em todo o conjunto)
year = as.numeric((names(max))), # converte os nomes de max (contém strings dos anos) em numérico
mon = deparse(which.mon[[m.i]]), # sequencia de meses analisados
station = station,               # nome da estação que está sendo analisada
stringsAsFactors = FALSE)
# Investigar: guardar a data em que ocorreu o máximo
return(df)
})
df <- do.call(rbind, max.subset)
return(df) # máximos para uma duração
}
# Chamar a função agg.ts dentro do parLapply (processamento paralelo) para calcular os máximos para todas as durações
if(cl > 1){ # Aplicar processamento paralelo
clust <- parallel::makeCluster(cl, type = "PSOCK")
data.agg <- parallel::parLapply(cl = clust,
X = ds,
fun = agg.ts)
parallel::stopCluster(clust)
} else{     # Não aplicar processamento paralelo
data.agg <- lapply(X = ds, agg.ts)
}
# Data.frame com máximos anuais para todas as durações em 'ds'
df <- do.call(rbind, data.agg)
return(df)
}
# Define quais estações utilizar
if(is.null(which.stations))which.stations <-
if(is.null(names(data))){
1:length(data)
} else{
names(data)
}
# Chama a função agg.station com lapply p/ agregar as durações para todas as estações
station.list <- pbapply::pblapply(which.stations, agg.station)
return(do.call('rbind', station.list))
}
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
ds <- ts_num/60                              # seconds to hours
ds <- ts_num/3600                              # seconds to hours
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
teste[2, "datetime"]
teste[2, "datetime"] - teste[1, "datetime"]
as.numeric(teste[2, "datetime"] - teste[1, "datetime"])
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "hour")
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "h")
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], unit = "hours")
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], unit = "hour")
difftime(teste[2, "datetime"], teste[1, "datetime"], unit = "hour")
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- IDF.agg(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- IDF::IDF.agg(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
as.numeric(teste[2, "datetime"], teste[1, "datetime"], units = "hour")
as.numeric(teste[2, "datetime"], teste[1, "datetime"], units = "hours")
teste <- current_list[[1]]
teste <- current_list[[1]]
teste <- current_list[[1]]
as.numeric(teste[2, "datetime"], teste[1, "datetime"], units = "hours")
teste[2, "datetime"]
teste[1, "datetime"]
as.numeric(teste[2, "datetime"], teste[1, "datetime"], units = "hours")
# Calcula a resolução temporal da estação baseado na diferença de tempo entre as duas primeiras observações do data.frame
dtime <- as.numeric(x = (data.s[2, names[1]] - data.s[1, names[1]]),
units = "hours")
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
teste[2, "datetime"], teste[1, "datetime"]
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
difftime(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
class(teste$datetime)
difftime(teste[2, "datetime"], teste[1, "datetime"], units = "hours")
pacman::p_load(pacman, tidyverse, beepr, lmom, pbapply, IDF)
teste[, names[1]]
teste[, names[1]][2]
teste[, names[1]][1]
teste[, "datetime"][1]
teste[1, "datetime"]
teste[2, "datetime"] - teste[1, "datetime"]
as.numeric(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
as.numeric(x = (teste[2, "datetime"] - teste[1, "datetime"]), units = "hours")
difftime(teste[2, "datetime"] - teste[1, "datetime"], units = "hours")
difftime(teste[2, "datetime"], teste[1, "datetime"], units = "hours")
teste[, "datetime"] %>% class
teste$datetime %>% class
as.numeric(x = (teste[2, "datetime"] - teste[1, "datetime"]), units = "seconds")
teste[2, "datetime"] %>% class
teste[2, "datetime"]x %>% class
teste[2, "datetime"]
View(data_by_ts)
data_by_ts[[ts]]
View(current_list)
teste <- teste %>% as.data.frame()
teste %>% class
teste[,names[1]]
teste[,names[1]][1]
teste[,names[1]][1]
teste[,names[1]][2]
teste[[,names[1]]]
teste[[,names[1]][1]]
teste[[, "datetime"]][1]
teste[[, "datetime"]]
teste[[1]]
teste[["datetime"]][1]
fun_agg_timeseries <- function(data,
ds,
na.accept = 0,
which.stations = NULL,
which.mon = list(0:11),
names = c("date", "RR"),
cl = 1){
# Confere se o argumento 'data' é uma lista
if(!inherits(data, "list")){
stop("Argument 'data' must be a list, insted it is a: ", class(data))
}
# Função 2: análises preliminares de consistência e encontrar a resolução temporal da estação 'dtime'
# Essa função calcula qual a resolução temporal que a estação apresenta baseado na diferença entre a data das duas primeiras observações
# depois confere se existe alguma observação nessa estação que a resolução sejea diferente e para o progresso da função caso encontre alguma
# que a diferença seja maior que a tolerância estabelecida e roda ao final a função de agregação
agg.station <- function(station){
# Extrai o data.frame para uma dada estação da lista
data.s <- data[[station]]
# Confere se data.s tem somente duas colunas, se tiver mais manter somente as em names
if (ncol(data.s) != 2){
data.s <- data.s[, names, drop = FALSE]
}
# Confere se a lista contém data.frames
if(!is.data.frame(data.s)){
stop("Elements of 'data' must be data.frames. But element ", station, " contains: ", class(data.s))
}
# Usa is.element() parar conferir se os nomes do argumento 'names' são os mesmos nomes das colunas dos data.frames
if(sum(is.element(names[1:2], names(data.s))) != 2){
stop("Data.frame of station ", station, " does not contain $", names[1], " or $", names[2], ".")
}
# Calcula a resolução temporal da estação baseado na diferença de tempo entre as duas primeiras observações do data.frame
dtime <- as.numeric(x = (data.s[[names[1]]][2] - data.s[[names[1]]][1]),
units = "hours")
# Confere as durações ewm 'ds' são múltiplas da resolução temporal da estação
if(any((ds/dtime) %% 1 > 1e-8)){
stop("At least one of the given aggregation durations is not multiple of the time resolution = ", dtime, " hours at station ", station, ".")
}
# Função 1: agregar por durações e encontrar o máximo anual de cada uma
# Usa o pacote RcppRoll para implementar funções do C++ de janela móvel (roll_sum e roll_mean) mais rápido que alternativas do R
agg.ts <- function(ds){
# Criar um vetor de somas móveis da coluna de precipitação, usando uma janela de ds/dtime
runsum <- RcppRoll::roll_sum(x = data.s[, names[2]], # vetor com dados da coluna 2 (precipitação)
n = round(ds/dtime),    # tamanho da janela móvel (ds é o vetor c/ as durações e dtime a resolução da estação)
fill = NA,              # preenche as pontas com NA
align = "right")        # alinha a janela à direita (no índice i)
# Converte a soma acumulada em intensidade por hora
runsum <- runsum/ds
# Analisa cada data.frame dentro da lista 'data' (por isso o lapply)
max.subset <-
lapply(1:length(which.mon),
function(m.i){
# Retornar um vetor lógico que marca como TRUE quais os meses que estão dentro do argumento 'which.mon'
subset <- is.element(as.POSIXlt(data.s[, names[1]])$mon, which.mon[[m.i]])
# Agrupa as observações por ano e compara o percentual de falhas com o na.accept
# ctapply() é uma versão otimizada da função tapply() que faz comparações baseadas em uma categoria (nesse caso o ano)
max <- fastmatch::ctapply(X = runsum[subset],                                           # somas móveis de cada mês analisado
INDEX = (as.POSIXlt(data.s[, names[1]])$year + 1900)[subset], # ano de cada mês com subset = TRUE
FUN = function(vec){                                          # máximo anual se n.falhas <= na.accept
# Número de NAs no ano agrupado
n.na <- sum(is.na(vec))
# Retorna o máximo anual caso a função tenha número de falhas aceitável
max <- ifelse(n.na <= na.accept*length(vec),
max(vec, na.rm = TRUE),
NA)
return(max)
})
# Data.frame resultante de máximos
df <- data.frame(xdat = max,                      # intensidades máximas anuais
ds = ds,                         # durações (cte em todo o conjunto)
year = as.numeric((names(max))), # converte os nomes de max (contém strings dos anos) em numérico
mon = deparse(which.mon[[m.i]]), # sequencia de meses analisados
station = station,               # nome da estação que está sendo analisada
stringsAsFactors = FALSE)
# Investigar: guardar a data em que ocorreu o máximo
return(df)
})
df <- do.call(rbind, max.subset)
return(df) # máximos para uma duração
}
# Chamar a função agg.ts dentro do parLapply (processamento paralelo) para calcular os máximos para todas as durações
if(cl > 1){ # Aplicar processamento paralelo
clust <- parallel::makeCluster(cl, type = "PSOCK")
data.agg <- parallel::parLapply(cl = clust,
X = ds,
fun = agg.ts)
parallel::stopCluster(clust)
} else{     # Não aplicar processamento paralelo
data.agg <- lapply(X = ds, agg.ts)
}
# Data.frame com máximos anuais para todas as durações em 'ds'
df <- do.call(rbind, data.agg)
return(df)
}
# Define quais estações utilizar
if(is.null(which.stations))which.stations <-
if(is.null(names(data))){
1:length(data)
} else{
names(data)
}
# Chama a função agg.station com lapply p/ agregar as durações para todas as estações
station.list <- pbapply::pblapply(which.stations, agg.station)
return(do.call('rbind', station.list))
}
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
list_agg <- list()
View(current_list)
View(df_agg)
View(current_list)
teste <- current_list[[1]]
View(teste)
as.numeric(x = (teste[["datetime"]][2] - teste[["datetime"]][1]), units = "seconds")
as.numeric(x = (teste[["datetime"]][2] - teste[["datetime"]][1]), units = "hours")
teste <- current_list[[1]]
dtime <- as.numeric(x = (teste[["datetime"]][2] - teste[["datetime"]][1]), units = "hours")
View(list_agg)
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = durations,      # durations
na.accept = 0.2,     # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
list_agg <- list()
durations <- c(0.25, 0.5, 1, 2, 4, 8, 2, 24, 48, 72)
for(ts in time_steps){
current_list <- data_by_ts[[ts]]
ts_num <- as.numeric(ts)
ds <- ts_num/3600                             # seconds to hours
valid_durations <- durations[durations >= ds] # adapt durations vector
df_agg <- fun_agg_timeseries(data = current_list,
ds = valid_durations, # durations
na.accept = 0.2,      # max 20% failure
names = c("datetime", "rain_mm"),
cl = 2)
list_agg[[ts]] <- df_agg
message(paste0("\nConjunto de estações com resolução de ", ds, " minutos processado!"))
}
